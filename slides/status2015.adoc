

Status JGroups 2015
===================
:author:    Bela Ban
:backend:   slidy
:max-width: 45em
:icons:

Agenda
------
* 3.6.2 - 3.6.7
* JGroups 4.0 and NIO.2
* JGroups workshops



JGroups 3.6.2
-------------

=== FORK: handling of asymmetric deployments
* If a fork stack or fork channel is not available on all nodes of `{A,B,C,D}`, a sync RPC to all 4 nodes will block
* Wildfly

=== Programmatic creation of a stack doesn't consider system props
* System props such as `-Djgroups.bind_addr` or `-Djgroups.external_addr` now work with a programmatic stack



JGroups 3.6.3
-------------

=== MERGE3 improvements
* Subgroups were incorrect
* Reduced number of rounds to merge edge-case splits
* Edge cases captured with unit tests

=== FILE_PING: option to remove zombie files
* Useful for all cloud discovery protocols (subclasses)



JGroups 3.6.4
-------------

=== SASL improvements

=== AZURE_PING
* Moved into its own GitHub repo due to dependencies (Rado)

=== FD_SOCK / FD: members are never unsuspected
* When a member Q is suspected by P, P periodically multicasts a `SUSPECT(Q)` until a new view (without Q) is installed
* This doesn't stop when Q is _unsuspected_
* OK in FD_ALL

=== Discovery: option to run each request in a separate thread
* Useful when using `TCP` as transport and the first couple of nodes (e.g. `A` - `C`) in
  `initial_hosts=A,B,C,D,E,F` are unresponsive or dead

=== Support IPv6 in AUTH
* Fixed membership would not recognize port `7800` in `fe80:0:0:0:20c:29ff:fe4d:e0c4%0:7800`
** Address without port is `fe80`

=== FORK: call life cycle methods
* Methods `start()`, `stop()` and `destroy()` of protocols in the fork stack are not called.
* Needed to add some ref-counting to call them on `ForkChannel.connect()/disconnect()/close()`. Also: destroy all
  fork stacks and their protocols on `FORK.destroy()`.

=== RELAY2: messages are lost
* When TransferQueueBundler (or any other bundler) receives messages (at the same time) to destinations `X` and
`SiteUUID("name", X)`, then they get sent in the same bundle, which is incorrect: one of the destinations will drop
a message
** Cause: missing impl of `equals()` and `hashCode()` in `SiteUUID`

=== TCP: unneeded copy of single message
* When receiving a single message (compared to a batch), there's an unneeded copy of the message in TCP

=== Probe: ping multiple clusters
* `probe.sh -addr 224.0.75.75 -addr 228.5.5.5`
* `java org.jgroups.tests.Probe -addr ff0e::0:75:75 -addr 192.168.1.3`




JGroups 3.6.5
-------------

=== TCP_NIO2: new transport
* See below

=== FORK: support state transfer
* All fork channels will get their individual states when `JChannel.getState()` is called

=== LockService.tryLock() can hang forever
* Caused by an incorrect conversion from nanos to millis

=== Table: longs wrap around incorrectly
* `Table` is a core class and is used by `NAKACK2` and `UNICAST3`
* `Long` wrap-around incorrect: messages are lost
* Very unlikely: adding 100 million messages/sec to a table would fill it in 15 years
** Unless some smart-ass dude injects a seqno of `Long.MAX_VALUE-100`... :-)
* Fixed by replacing `if(seq1 < seq2) ...` and `if(seq2 >= seq1) ...` by `if(seq1 - seq2 < 0) ...`
  and `if(seq2 - seq1 >= 0) ...`
* Unit test is `TableTest.testSeqnoOverflow()`

=== OpenStack discovery protocol failure
* `SWIFT_PING` failed with OpenStack "Kilo"
* Reason: OpenStack Identity API switched from using XML to JSON

=== S3_PING / FILE_PING improvements
* When members are killed ungracefully

=== GossipRouter: use NIO building blocks to rewrite
* TcpClient, NioClient, TcpServer, NioServer
* These classes are also used to implement `TCP_NIO2`




JGroups 3.6.6
-------------

=== TCP_NIO2: fixed 2 critical bugs
* Non-blocking sending of message batches and reusing of the bundler's buffer caused message corruption
* Messages keep piling up because the selector doesn't have a registration for `OP_READ` / `OP_WRITE`
** Cause: `SelectionKey.interestOps(ops)` is not thread safe, therefore concurrent registrations / de-registrations
   could lead to dropped registrations




JGroups 3.6.7 (wip)
-------------------

=== Back to using a MulticastSocket (instead of a DatagramSocket) to send multicast messages
* Fixes ip_ttl issue on Windows (exception when using IPv6)
* Performance is the same
* No need to change routing table on MacOS anymore

=== SASL and merging
* Merging wasn't handled




JGroups workshops
-----------------
* 4 workshops: Berlin (16 people), Rome (15 people), NYC (22) and Mountain View (4)
* 20 paying customers (money used to partially fund F2Fs)
* 2 workshops in 2016 ?





TCP_NIO2
--------

=== What is it ?
* A new _non-blocking_ TCP transport based on NIO.2
* Replaces `TCP_NIO` (deprecated a long time ago)
* The (medium term) goal is to replace `TCP` as well
* Brand new, don't use in production yet (wait for 2-3 minor releases)
** But please experiment, benchmark etc
** Perf with `UPerf` and `MPerf` slightly better than `TCP`, but slower running the Infinispan testsuite
   (still need to investigate)


=== Features
* Never blocks on reads, writes, accepts or connects
** We've had quite a few problems with threads blocked in TCP writes in the past
* Dramatic reduction of threads required: from `(N-1)*2` -> `1`
** _One_ thread for _all_ peer nodes (`TCP`: 2 threads per peer node)
* Still requires `N-1` TCP connections (like `TCP`)


=== How ?
* The only blocking call is `select()` -> called by the (*one*) thread in `TCP_NIO2`
* Accepts, connects and writes are handled directly by the selector thread, reads are passed to the transport's thread pool
* Built by using reusable classes `TcpServer`, `NioServer`, `TcpClient` and `NioClient`
** Goal: mix blocking/non-blocking clients and blocking/non-blocking servers
** Used to rewrite `GossipRouter` (now very scalable), `TCPGOSSIP` (`RouterStub`), `TUNNEL`




JGroups 4.0
-----------

